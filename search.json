[{"title":"An Intro to DL for the Physical Layer","url":"/2024/05/30/An%20Intro%20to%20DL%20for%20Physical%20Layer/","content":"<h2 id=\"文章出处\"><a href=\"#文章出处\" class=\"headerlink\" title=\"文章出处\"></a>文章出处</h2><p>O’shea T, Hoydis J. An introduction to deep learning for the physical layer[J]. IEEE Transactions on Cognitive Communications and Networking, 2017, 3(4): 563-575.(Citations 2607)  </p>\n<h2 id=\"论文总览\"><a href=\"#论文总览\" class=\"headerlink\" title=\"论文总览\"></a>论文总览</h2><ul>\n<li><p>主要内容：文章是一篇综述类文章，总结了ML在通信系统物理层上的应用，提出相关观点，并在该领域进行展望</p>\n</li>\n<li><p>主要贡献：</p>\n</li>\n</ul>\n<ol>\n<li>证明使用DNN网络代替发射机、接收机以及信道等通信系统部分是可行的，并可适用于最优解未知的通道模型和损失函数  </li>\n<li>证明上述概念可以扩展至多发多收场景下，利用神经网络有助于解决干扰信道问题。同时，收发机的实现可以根据公共或单独的性能指标进行联合优化  </li>\n<li>介绍了 <code>radio transformer networks</code> ，该网络可以在接收机融入预定义校正算法。该网络可以集成对变换信号执行的任务到端到端训练过程中</li>\n<li>研究了NN在复值样本上解决调制分类问题的可行性，证明其学习到的特征优于并可以取代传统方式</li>\n</ol>\n<h2 id=\"DL在物理层上的潜力\"><a href=\"#DL在物理层上的潜力\" class=\"headerlink\" title=\"DL在物理层上的潜力\"></a>DL在物理层上的潜力</h2><ol>\n<li>传统方式对通信系统的建模很难完美描述其实际特性，使用DL可以降低模型对数学可处理性的要求，同时可以针对特定硬件和无法完美描述的信道进行优化</li>\n<li>传统通信系统设计要求信号处理过程模块化、流程化，但模块化的通信系统已被证明为是次优的，而模块之间的联合优化会使得各个模块的实现十分繁琐，使用DL取代传统物理层不会被严格区分为各个模块，它是针对端到端性能进行优化  </li>\n<li>神经网络的运行能够有很高的并行度和更低的数据精度，因此可以执行速度更快、功耗更低</li>\n<li>结合第3点，目前有足以支撑神经网络计算的硬件平台，例如：GPU、Eyeriss架构等。在这些架构上可以轻松实现高资源利用率、高吞吐量，并只需要最少的特定于应用程序的调整或优化</li>\n</ol>\n","categories":["论文阅读-通信系统"],"tags":["Physical Layer","Deep Learning","Literature Review"]},{"title":"Vitis HLS 基础","url":"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/","content":"<p>Vitis HLS 基础学习笔记</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"1-任意精度数据类型\"><a href=\"#1-任意精度数据类型\" class=\"headerlink\" title=\"1. 任意精度数据类型\"></a>1. 任意精度数据类型</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;ap_int.h&gt;</span><br><span class=\"line\">ap_[u]int&lt;W&gt;  // 最大可扩展至32k位</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;ap_fixed.h&gt;</span><br><span class=\"line\">ap_[u]fixed&lt;W, I, Q, O&gt;    // W总位宽、I整数位宽、Q量化模式、O溢出模式</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-变量初始化\"><a href=\"#2-变量初始化\" class=\"headerlink\" title=\"2. 变量初始化\"></a>2. 变量初始化</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ap_int&lt;6&gt; a_6bit_var_c = -22;</span><br><span class=\"line\">ap_int&lt;6&gt; a_6bit_var_d(22);</span><br><span class=\"line\">ap_int&lt;6&gt; a_6bit_var_r2(&quot;0b101010&quot;, 2);   // 指定进制数</span><br><span class=\"line\">ap_int&lt;6&gt; a_6bit_var_r2(&quot;101010&quot;, 2);</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-数据类型转换\"><a href=\"#3-数据类型转换\" class=\"headerlink\" title=\"3. 数据类型转换\"></a>3. 数据类型转换</h3><p>显示转换</p>\n<pre><code>(Expected type) Variable\nExpected type (Variable)\n</code></pre>\n<p>常用运算的数据类型转换</p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/1.jpg\" class=\"\" title=\"数据类型转换\">  \n<p>可以使用<code>&lt;typeinfo&gt;</code>库文件中的<code>typeid</code>来查看数据类型</p>\n<h2 id=\"for循环优化\"><a href=\"#for循环优化\" class=\"headerlink\" title=\"for循环优化\"></a>for循环优化</h2><h3 id=\"1-衡量指标\"><a href=\"#1-衡量指标\" class=\"headerlink\" title=\"1. 衡量指标\"></a>1. 衡量指标</h3><p><code>Loop Trip Count</code>：循环触发次数<br><code>Loop Iteration Latency</code>：迭代延时（单次迭代时延）<br><code>Loop Iteration Interval</code>：迭代间隔（两次迭代间隔）<br><code>Loop Latency</code>：循环时延（迭代时延 * 迭代次数）<br><code>Function Latency</code>：函数时延（完整for循环执行时延）<br><code>Function Iteration Interval</code>：函数间隔（两次循环的间隔，考虑到循环条件的判断，可能会多一个周期）</p>\n<h3 id=\"2-流水线处理\"><a href=\"#2-流水线处理\" class=\"headerlink\" title=\"2. 流水线处理\"></a>2. 流水线处理</h3><p>使用<code>#pragma HLS PIPLINE</code>添加约束  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/for_pipline.png\" class=\"\" title=\"流水线处理\">  \n<p>流水线处理使得数据读取、计算、存储三个过程在一定程度上并行处理，即上一个数据在计算过程中就开始读取下一个数据  </p>\n<h3 id=\"3-循环展开\"><a href=\"#3-循环展开\" class=\"headerlink\" title=\"3. 循环展开\"></a>3. 循环展开</h3><p>使用<code>#pragma HLS UNROLL</code>添加约束  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/for_unroll.png\" class=\"\" title=\"循环展开\">    \n<p>可以根据循环迭代参数<code>i</code>对循环计算并行处理，同时可以约束展开的子循环个数  </p>\n<h3 id=\"4-循环融合\"><a href=\"#4-循环融合\" class=\"headerlink\" title=\"4. 循环融合\"></a>4. 循环融合</h3><p>使用<code>#pragma HLS merge</code>添加约束  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/merge.png\" class=\"\" title=\"循环融合\">   \n<p>循环融合可以将两个不具有顺序逻辑的循环同时执行<br>循环边界的界定如下：</p>\n<ul>\n<li><code>Loop_A</code>的循环次数为<code>M</code>，<code>Loop_B</code>的循环次数为<code>N</code>，合并后循环次数为<code>MAX(M, N)</code>  </li>\n<li>若一个循环边界为变量，另一个为常量时，无法合并  </li>\n<li>两个循环边界均为变量时，可以约束为共同循环部分和额外循环部分</li>\n</ul>\n<h3 id=\"5-数据流处理\"><a href=\"#5-数据流处理\" class=\"headerlink\" title=\"5. 数据流处理\"></a>5. 数据流处理</h3><p>使用<code>#pragma HLS dataflow</code>添加约束  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/dataflow.png\" class=\"\" title=\"数据流处理\">  \n<p>数据流处理用于处理多循环连接问题，循环之间的通道使用<code>RAM</code>、<code>FIFO</code>或<code>Reg</code>实现，加速方式为在<code>Loop_B</code>处理的同时<code>Loop_A</code>进行下一组数据的处理  </p>\n<h4 id=\"dataflow的局限性与解决方式\"><a href=\"#dataflow的局限性与解决方式\" class=\"headerlink\" title=\"dataflow的局限性与解决方式\"></a><code>dataflow</code>的局限性与解决方式</h4><p>当出现一个循环的结果要送入两个不同循环进行后续处理的情况时，无法直接使用dataflow  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/dataflow%E5%B1%80%E9%99%90%E6%80%A71.png\" class=\"\" title=\"dataflow局限性1\">   \n<p>此时需要将第一个循环结果复制之后，分别送入两个循环  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/dataflow1.png\" class=\"\" title=\"dataflow局限性1处理\">   \n\n<p>当出现一个循环结果经过不同处理过程最终又送入一个循环的情况时，无法直接使用dataflow  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/dataflow%E5%B1%80%E9%99%90%E6%80%A72.png\" class=\"\" title=\"dataflow局限性2\">   \n<p>此时需要保证两个分支经过相同的处理模块，不需要处理时在模块内为简单的复制  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/dataflow2.png\" class=\"\" title=\"dataflow局限性2处理\">     \n","categories":["HLS"],"tags":["Vitis HLS","FPGA"]},{"title":"博客搭建（hexo+github）","url":"/2024/05/09/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88hexo-github%EF%BC%89/","content":"<h2 id=\"博客搭建基本流程（hexo-github）\"><a href=\"#博客搭建基本流程（hexo-github）\" class=\"headerlink\" title=\"博客搭建基本流程（hexo + github）\"></a>博客搭建基本流程（hexo + github）</h2><h3 id=\"hexo环境搭建\"><a href=\"#hexo环境搭建\" class=\"headerlink\" title=\"hexo环境搭建\"></a>hexo环境搭建</h3><p>hexo环境搭建需要下载node.js、git，下载之后在cmd中输入下面命令检查node、npm、git是否安装成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; node -v</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; npm -v</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; git -v</span><br></pre></td></tr></table></figure>\n\n<p>确认node.js、git安装无误后，使用git bash进行hexo的安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>安装完成之后，创建一个博客文件夹，在git bash中输入如下命令进行初始化和本地预览</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo init                           <span class=\"comment\"># 初始化</span></span><br><span class=\"line\">$ hexo install                        <span class=\"comment\"># 安装组件</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ hexo generate                       <span class=\"comment\"># 生成页面 （可以简写为 hexo g ）</span></span><br><span class=\"line\">$ hexo server                         <span class=\"comment\"># 预览 （默认端口为4000，若被占用可以通过 -p 更换端口）</span></span><br></pre></td></tr></table></figure>\n\n<p>此时访问”localhost:4000”即可预览博客</p>\n<p>博客文件夹目录结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">- _config.yml                          # 站点配置信息  </span><br><span class=\"line\">- package.json                         # 应用程序信息  </span><br><span class=\"line\">- scaffolds                            # 模板文件  </span><br><span class=\"line\">- source                               # 存放用户源文件  </span><br><span class=\"line\">- themes                               # 存放主题文件  </span><br><span class=\"line\">- public                               # 静态网站文件</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"部署到github\"><a href=\"#部署到github\" class=\"headerlink\" title=\"部署到github\"></a>部署到github</h3><p>在部署之前要确保主机通过ssh密钥域github连接，可通过如下命令进行检查</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n\n<p>连接成功后在github中新建博客仓库，仓库名称为”username.github.io”，username为github用户名<br>创建完成之后对<code>_config.yml</code>文件中的deploy部分进行如下修改，将博客部署在main分支</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: git@github.com:Allure-Luv/Allure-Luv.github.io.git</span><br><span class=\"line\">  branch: main</span><br></pre></td></tr></table></figure>\n\n<p>修改完成后，运行如下命令进行部署</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo cl</span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n\n<p>部署之后可以访问<code>username.github.io</code>来查看部署情况</p>\n<h2 id=\"跨设备移植博客\"><a href=\"#跨设备移植博客\" class=\"headerlink\" title=\"跨设备移植博客\"></a>跨设备移植博客</h2><p>根据上述步骤，博客部署在main分支，利用git分支机制，将源码推送至另一分支，即可实现源码的保存<br>在更换设备后，仅需要搭建hexo环境，从github中拉取源码即可，具体步骤如下：<br>a. 在github中创建新的分支，这里为<code>gh-pages</code>，并将其设置为默认分支，为了每次方便上传源码<br>b. 在本地拉取新创建的新分支<br>c. 将文件夹中除<code>.git</code>文件之外所有文件均删除<br>d. 将博客源码除<code>.deploy_git</code>文件复制到拉取的文件夹中（注意要有.gitignore文件）<br>e. 将本地仓库推送至远端仓库<br>注：因为git不支持嵌套，因此在github中拉取的主题中的.git文件需要删除  </p>\n<h2 id=\"博客资源管理\"><a href=\"#博客资源管理\" class=\"headerlink\" title=\"博客资源管理\"></a>博客资源管理</h2><p>通常在 <code>source/images</code> 文件夹下可以存放文章所引用的图片，但当资源较多时，可以启用资源管理文件夹实现分组管理<br>在 <code>_config.yml</code> 文件中置 <code>post_asset_folder</code> 选项为true，这样在进行博客创建的时候，会自动创建一个与文章同名的文件夹用于放置文章引用的资源<br>在这种方式下，图片、链接等无法使用<code>markdown</code>语法链接，具体链接方式为：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% asset_path slug %&#125;</span><br><span class=\"line\">&#123;% asset_img slug [title] %&#125;</span><br><span class=\"line\">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure>","categories":["博客搭建"],"tags":["hexo","github"]}]