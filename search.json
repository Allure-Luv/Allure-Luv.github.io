[{"title":"An Intro to DL for the Physical Layer","url":"/2024/05/30/An%20Intro%20to%20DL%20for%20Physical%20Layer/","content":"<h2 id=\"文章出处\"><a href=\"#文章出处\" class=\"headerlink\" title=\"文章出处\"></a>文章出处</h2><p>O’shea T, Hoydis J. An introduction to deep learning for the physical layer[J]. IEEE Transactions on Cognitive Communications and Networking, 2017, 3(4): 563-575.(Citations 2607)  </p>\n<h2 id=\"论文总览\"><a href=\"#论文总览\" class=\"headerlink\" title=\"论文总览\"></a>论文总览</h2><ul>\n<li><p>主要内容：文章是一篇综述类文章，总结了ML在通信系统物理层上的应用，提出相关观点，并在该领域进行展望</p>\n</li>\n<li><p>主要贡献：</p>\n</li>\n</ul>\n<ol>\n<li>证明使用DNN网络代替发射机、接收机以及信道等通信系统部分是可行的，并可适用于最优解未知的通道模型和损失函数  </li>\n<li>证明上述概念可以扩展至多发多收场景下，利用神经网络有助于解决干扰信道问题。同时，收发机的实现可以根据公共或单独的性能指标进行联合优化  </li>\n<li>介绍了 <code>radio transformer networks</code> ，该网络可以在接收机融入预定义校正算法。该网络可以集成对变换信号执行的任务到端到端训练过程中</li>\n<li>研究了NN在复值样本上解决调制分类问题的可行性，证明其学习到的特征优于并可以取代传统方式</li>\n</ol>\n<h2 id=\"DL在物理层上的潜力\"><a href=\"#DL在物理层上的潜力\" class=\"headerlink\" title=\"DL在物理层上的潜力\"></a>DL在物理层上的潜力</h2><ol>\n<li>传统方式对通信系统的建模很难完美描述其实际特性，使用DL可以降低模型对数学可处理性的要求，同时可以针对特定硬件和无法完美描述的信道进行优化</li>\n<li>传统通信系统设计要求信号处理过程模块化、流程化，但模块化的通信系统已被证明为是次优的，而模块之间的联合优化会使得各个模块的实现十分繁琐，使用DL取代传统物理层不会被严格区分为各个模块，它是针对端到端性能进行优化  </li>\n<li>神经网络的运行能够有很高的并行度和更低的数据精度，因此可以执行速度更快、功耗更低</li>\n<li>结合第3点，目前有足以支撑神经网络计算的硬件平台，例如：GPU、Eyeriss架构等。在这些架构上可以轻松实现高资源利用率、高吞吐量，并只需要最少的特定于应用程序的调整或优化</li>\n</ol>\n<h2 id=\"相关工作\"><a href=\"#相关工作\" class=\"headerlink\" title=\"相关工作\"></a>相关工作</h2><p>当前DL在物理层的应用分为两个方面：  </p>\n<ul>\n<li>使用DL增强现有算法  </li>\n<li>使用DL完全取代现有算法</li>\n</ul>\n<h3 id=\"使用DL增强现有算法\"><a href=\"#使用DL增强现有算法\" class=\"headerlink\" title=\"使用DL增强现有算法\"></a>使用DL增强现有算法</h3><p>这方面应用源于现有迭代算法的深度展开，将每次迭代解释为一组NN  </p>\n<h3 id=\"完全取代现有算法\"><a href=\"#完全取代现有算法\" class=\"headerlink\" title=\"完全取代现有算法\"></a>完全取代现有算法</h3><p>这方面应用直接推翻传统算法，完全使用DL实现如功率控制、调制识别、信号压缩、信道编码等</p>\n<h2 id=\"机器学习在物理层的应用\"><a href=\"#机器学习在物理层的应用\" class=\"headerlink\" title=\"机器学习在物理层的应用\"></a>机器学习在物理层的应用</h2><h3 id=\"AutoEncoder-实现端到端通信系统\"><a href=\"#AutoEncoder-实现端到端通信系统\" class=\"headerlink\" title=\"AutoEncoder 实现端到端通信系统\"></a><code>AutoEncoder</code> 实现端到端通信系统</h3><h3 id=\"AutoEncoder-实现多发多收通信系统\"><a href=\"#AutoEncoder-实现多发多收通信系统\" class=\"headerlink\" title=\"AutoEncoder 实现多发多收通信系统\"></a><code>AutoEncoder</code> 实现多发多收通信系统</h3><h3 id=\"Radio-Transformer-networks-实现增强信号处理算法\"><a href=\"#Radio-Transformer-networks-实现增强信号处理算法\" class=\"headerlink\" title=\"Radio Transformer networks 实现增强信号处理算法\"></a><code>Radio Transformer networks</code> 实现增强信号处理算法</h3><h3 id=\"CNNs-用于分类任务\"><a href=\"#CNNs-用于分类任务\" class=\"headerlink\" title=\"CNNs 用于分类任务\"></a><code>CNNs</code> 用于分类任务</h3>","categories":["论文阅读-通信系统"],"tags":["Physical Layer","Deep Learning","Literature Review"]},{"title":"Vitis HLS 基础","url":"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/","content":"<p>Vitis HLS 基础学习笔记</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"1-任意精度数据类型\"><a href=\"#1-任意精度数据类型\" class=\"headerlink\" title=\"1. 任意精度数据类型\"></a>1. 任意精度数据类型</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;ap_int.h&gt;</span><br><span class=\"line\">ap_[u]int&lt;W&gt;  // 最大可扩展至32k位</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;ap_fixed.h&gt;</span><br><span class=\"line\">ap_[u]fixed&lt;W, I, Q, O&gt;    // W总位宽、I整数位宽、Q量化模式、O溢出模式</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-变量初始化\"><a href=\"#2-变量初始化\" class=\"headerlink\" title=\"2. 变量初始化\"></a>2. 变量初始化</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ap_int&lt;6&gt; a_6bit_var_c = -22;</span><br><span class=\"line\">ap_int&lt;6&gt; a_6bit_var_d(22);</span><br><span class=\"line\">ap_int&lt;6&gt; a_6bit_var_r2(&quot;0b101010&quot;, 2);   // 指定进制数</span><br><span class=\"line\">ap_int&lt;6&gt; a_6bit_var_r2(&quot;101010&quot;, 2);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-数据类型转换\"><a href=\"#3-数据类型转换\" class=\"headerlink\" title=\"3. 数据类型转换\"></a>3. 数据类型转换</h3><p>显示转换</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(Expected type) Variable</span><br><span class=\"line\">Expected type (Variable)</span><br></pre></td></tr></table></figure>\n\n<p>常用运算的数据类型转换</p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/1.jpg\" class=\"\" title=\"数据类型转换\">  \n<p>可以使用<code>&lt;typeinfo&gt;</code>库文件中的<code>typeid</code>来查看数据类型</p>\n<h2 id=\"for循环优化\"><a href=\"#for循环优化\" class=\"headerlink\" title=\"for循环优化\"></a>for循环优化</h2><h3 id=\"1-衡量指标\"><a href=\"#1-衡量指标\" class=\"headerlink\" title=\"1. 衡量指标\"></a>1. 衡量指标</h3><p><code>Loop Trip Count</code>：循环触发次数<br><code>Loop Iteration Latency</code>：迭代延时（单次迭代时延）<br><code>Loop Iteration Interval</code>：迭代间隔（两次迭代间隔）<br><code>Loop Latency</code>：循环时延（迭代时延 * 迭代次数）<br><code>Function Latency</code>：函数时延（完整for循环执行时延）<br><code>Function Iteration Interval</code>：函数间隔（两次循环的间隔，考虑到循环条件的判断，可能会多一个周期）</p>\n<h3 id=\"2-流水线处理\"><a href=\"#2-流水线处理\" class=\"headerlink\" title=\"2. 流水线处理\"></a>2. 流水线处理</h3><p>使用<code>#pragma HLS PIPLINE</code>添加约束  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/for_pipline.png\" class=\"\" title=\"流水线处理\">  \n<p>流水线处理使得数据读取、计算、存储三个过程在一定程度上并行处理，即上一个数据在计算过程中就开始读取下一个数据  </p>\n<h3 id=\"3-循环展开\"><a href=\"#3-循环展开\" class=\"headerlink\" title=\"3. 循环展开\"></a>3. 循环展开</h3><p>使用<code>#pragma HLS UNROLL</code>添加约束  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/for_unroll.png\" class=\"\" title=\"循环展开\">    \n<p>可以根据循环迭代参数<code>i</code>对循环计算并行处理，同时可以约束展开的子循环个数  </p>\n<h3 id=\"4-循环融合\"><a href=\"#4-循环融合\" class=\"headerlink\" title=\"4. 循环融合\"></a>4. 循环融合</h3><p>使用<code>#pragma HLS merge</code>添加约束  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/merge.png\" class=\"\" title=\"循环融合\">   \n<p>循环融合可以将两个不具有顺序逻辑的循环同时执行<br>循环边界的界定如下：</p>\n<ul>\n<li><code>Loop_A</code>的循环次数为<code>M</code>，<code>Loop_B</code>的循环次数为<code>N</code>，合并后循环次数为<code>MAX(M, N)</code>  </li>\n<li>若一个循环边界为变量，另一个为常量时，无法合并  </li>\n<li>两个循环边界均为变量时，可以约束为共同循环部分和额外循环部分</li>\n</ul>\n<h3 id=\"5-数据流处理\"><a href=\"#5-数据流处理\" class=\"headerlink\" title=\"5. 数据流处理\"></a>5. 数据流处理</h3><p>使用<code>#pragma HLS dataflow</code>添加约束  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/dataflow.png\" class=\"\" title=\"数据流处理\">  \n<p>数据流处理用于处理多循环连接问题，循环之间的通道使用<code>RAM</code>、<code>FIFO</code>或<code>Reg</code>实现，加速方式为在<code>Loop_B</code>处理的同时<code>Loop_A</code>进行下一组数据的处理</p>\n<h4 id=\"dataflow的局限性与解决方式\"><a href=\"#dataflow的局限性与解决方式\" class=\"headerlink\" title=\"dataflow的局限性与解决方式\"></a><code>dataflow</code>的局限性与解决方式</h4><p>当出现一个循环的结果要送入两个不同循环进行后续处理的情况时，无法直接使用dataflow  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/dataflow%E5%B1%80%E9%99%90%E6%80%A71.png\" class=\"\" title=\"dataflow局限性1\">   \n<p>此时需要将第一个循环结果复制之后，分别送入两个循环  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/dataflow1.png\" class=\"\" title=\"dataflow局限性1处理\">   \n\n<p>当出现一个循环结果经过不同处理过程最终又送入一个循环的情况时，无法直接使用dataflow  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/dataflow%E5%B1%80%E9%99%90%E6%80%A72.png\" class=\"\" title=\"dataflow局限性2\">   \n<p>此时需要保证两个分支经过相同的处理模块，不需要处理时在模块内为简单的复制  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/dataflow2.png\" class=\"\" title=\"dataflow局限性2处理\">     \n\n<h4 id=\"dataflow的存储管理\"><a href=\"#dataflow的存储管理\" class=\"headerlink\" title=\"dataflow的存储管理\"></a><code>dataflow</code>的存储管理</h4><p>标量、指针、引用变量以及函数返回值，HLS使用FIFO实现通道<br>数组，<code>HLS</code>使用<code>FIFO</code>或<code>ping-pong ram</code>实现：  </p>\n<ul>\n<li>若HLS确定数据流为顺序的，则默认使用深度为1的FIFO  </li>\n<li>若不能确定则使用<code>ping-pong ram</code></li>\n</ul>\n<p>上述配置可以在<code>congfig_dataflow</code>中配置，明确设定FIFO深度，存储器尺寸等  </p>\n<h3 id=\"6-嵌套循环优化\"><a href=\"#6-嵌套循环优化\" class=\"headerlink\" title=\"6. 嵌套循环优化\"></a>6. 嵌套循环优化</h3><p>嵌套循环主要通过<code>pipline</code>进行优化，<code>pipline</code>会合并上层循环、展开下层循环</p>\n<h4 id=\"a-循环边界为常数，循环体仅在最内层循环\"><a href=\"#a-循环边界为常数，循环体仅在最内层循环\" class=\"headerlink\" title=\"a. 循环边界为常数，循环体仅在最内层循环\"></a>a. 循环边界为常数，循环体仅在最内层循环</h4><p>对外层循环做pipline处理，会使内部循环全部展开，可以达到最低延时但是会消耗更多资源<br>对内层循环做pipline处理，会使外部循环展开，即若外部循环边界为<code>M</code>，内部循环边界为<code>N</code>，相当于执行<code>M*N</code>次内部循环，效果介于不处理和对外层循环处理之间<br>注：<code>Loop_flatten</code>展开最外层循环要求必须为<code>a</code>、<code>b</code>两种情况</p>\n<h4 id=\"b-循环边界为常数，循环体存在多层循环\"><a href=\"#b-循环边界为常数，循环体存在多层循环\" class=\"headerlink\" title=\"b. 循环边界为常数，循环体存在多层循环\"></a>b. 循环边界为常数，循环体存在多层循环</h4><p>以如下代码为例：  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/imperfect_loop1.png\" class=\"\" title=\"非完美循环示例\">  \n\n<p>若对最内层做<code>pipline</code>处理，由于在<code>Col</code>循环内存在初始化，无法展开，仅能对<code>Row</code>和<code>Col</code>进行展开，最终结果为两层嵌套循环<br>若对中间层循环做<code>pipline</code>处理，仍为展开<code>Row</code>和<code>Col</code>，同时展平最内层循环，最终仅有一层循环<br>若对最外层循环做<code>pipline</code>处理，会展开所有子循环，即最终仅有一层循环且循环边界为<code>Col</code>的循环边界</p>\n<h4 id=\"unroll-vs-flatten\"><a href=\"#unroll-vs-flatten\" class=\"headerlink\" title=\"unroll vs flatten\"></a>unroll vs flatten</h4><p>对于for循环嵌套来说，<code>flatten</code>为合并两次循环，<code>unroll</code>为单个循环  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Loop_A:</span><br><span class=\"line\">for (i = 0; i &lt; 3; i++) &#123;</span><br><span class=\"line\">    Loop_B:</span><br><span class=\"line\">    for (j = 0; j &lt; 3; j++) &#123;</span><br><span class=\"line\">        Loop_C:</span><br><span class=\"line\">        for (k = 0; k &lt; 3; k++) &#123;</span><br><span class=\"line\">            Loop_Entiy;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>若对<code>Loop_B</code>使用<code>pipline</code>进行优化，HLS会合并（flatten）上层循环，展开（unroll）下层循环<br>合并<code>Loop_A</code>与<code>Loop_B</code>，即外部循环变为一个同时循环边界为两个循环的和<br>展开<code>Loop_C</code>，即同时计算<code>Loop_C</code>下每个循环变量对应的循环体<br>故最终约束结果为对3个<code>Loop_Entity</code>循环6次</p>\n<h3 id=\"7-for循环其他优化\"><a href=\"#7-for循环其他优化\" class=\"headerlink\" title=\"7. for循环其他优化\"></a>7. for循环其他优化</h3><h4 id=\"函数实例的并行计算\"><a href=\"#函数实例的并行计算\" class=\"headerlink\" title=\"函数实例的并行计算\"></a>函数实例的并行计算</h4><p>使用<code>#pragma HLS ALLOCATIN instances=  limit=</code>实现函数并行约束<br>上述约束可以实现函数的示例，并进行并行计算  </p>\n<h4 id=\"pipline-rewind\"><a href=\"#pipline-rewind\" class=\"headerlink\" title=\"pipline rewind\"></a>pipline rewind</h4><p>在<code>pipline</code>的约束下，选用<code>rewind</code>选项，可以实现不同循环之间的流水线处理  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/rewind.png\" class=\"\" title=\"pipline rewind\">  \n\n<h4 id=\"循环边界为变量\"><a href=\"#循环边界为变量\" class=\"headerlink\" title=\"循环边界为变量\"></a>循环边界为变量</h4><p>循环边界为变量时，无法确定延时，解决方案如下：  </p>\n<ul>\n<li>设定<code>tripcount</code>参数  </li>\n<li>指定循环边界的数据类型为<code>ap_(u)int</code></li>\n<li>使用<code>assert</code></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;assert.h&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">void test() &#123;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    assert (width &lt; 5);</span><br><span class=\"line\">    for (i = 0; i &lt; width; i++) &#123;</span><br><span class=\"line\">        Loop_Entity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>三种方式相比之下采用assert延时最短使用资源最少  </p>\n<h2 id=\"数组优化\"><a href=\"#数组优化\" class=\"headerlink\" title=\"数组优化\"></a>数组优化</h2><p>在HLS中，根据数组所处位置会综合为不同的电路：<br>若数组为顶层函数接口，则会综合为用于访问外部存储器的RTL端口<br>若数组为函数内部数组，则根据约束综合为<code>BRAM</code>、<code>LUTRAM</code>、<code>UltraRAM</code>或<code>Register</code>  </p>\n<p>使用<code>#pragma HLS RESOURCE</code>可以约束实现数组的存储器类型如单口RAM、双口RAM等</p>\n<h3 id=\"1-数组分割（Array-Partition）\"><a href=\"#1-数组分割（Array-Partition）\" class=\"headerlink\" title=\"1. 数组分割（Array Partition）\"></a>1. 数组分割（Array Partition）</h3><p>数组分割的目的在于提高数据吞吐量<br>使用<code>#pragma HLS ARRAY_PARTITION</code>实现数组分割 </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/array_partition.png\" class=\"\" title=\"数组分割\">\n\n<p>分割方式有三种：<br><code>block</code>：将数组按照顺序划分<br><code>cyclic</code>：将数组按照顺序划分后每个<code>block</code>取出一个元组构成分区<br><code>complete</code>：将数组完全拆开，使用寄存器形式  </p>\n<p>多维数组在分割时需要指定分割维度  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%86%E5%89%B2.png\" class=\"\" title=\"多维数组分割\">  \n\n<h3 id=\"2-数组映射和重组\"><a href=\"#2-数组映射和重组\" class=\"headerlink\" title=\"2. 数组映射和重组\"></a>2. 数组映射和重组</h3><p>数组重组的目的在于减少资源消耗<br>使用<code>#pragma HLS ARRAY_MAP</code>进行数组映射</p>\n<h4 id=\"水平映射\"><a href=\"#水平映射\" class=\"headerlink\" title=\"水平映射\"></a>水平映射</h4><p>将数组<code>A[M]</code>、<code>B[N]</code>水平拼接，长度变为<code>M+N</code>，位宽可以不同，合并后为两者的最大值<br>通过设置<code>offset</code>参数可以使两个数组在合并时中间存在偏移量  </p>\n<h4 id=\"纵向映射\"><a href=\"#纵向映射\" class=\"headerlink\" title=\"纵向映射\"></a>纵向映射</h4><p>纵向映射即对两个数组在对应位置处进行拼接，长度为较长数组的长度，位宽为两个数组位宽之和  </p>\n<img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E7%BA%B5%E5%90%91%E6%8B%BC%E6%8E%A5.png\" class=\"\" title=\"数组纵向拼接\">  \n\n<h4 id=\"数组变形\"><a href=\"#数组变形\" class=\"headerlink\" title=\"数组变形\"></a>数组变形</h4><p>数组变形的本质是将数组分割之后再重组，针对同一个数组，分割方式类比数组分割<br>使用<code>#pragma HLS ARRAY_RESHAPE</code>实现  </p>\n<h3 id=\"3-定义ROM\"><a href=\"#3-定义ROM\" class=\"headerlink\" title=\"3. 定义ROM\"></a>3. 定义ROM</h3><p>使用<code>const + initial value</code>可以定义一个<code>ROM</code>  </p>\n<p>为了方便维护可以在头文件中进行ROM的定义，注意引用方式  </p>\n<pre><code>const ap_int&lt;8&gt; COEF[N] = &#123;\n    #include &quot;data.dat&quot;\n&#125;;\n\nconst ap_int&lt;8&gt; COEF[N] = &#123; #include &quot;data.dat&quot; &#125;;\n</code></pre>\n<p>在上述定义中，方式一可行、方式二不可行  </p>\n<p>通过提高输出延时可以有效调整时序  </p>\n<h3 id=\"4-数组初始化\"><a href=\"#4-数组初始化\" class=\"headerlink\" title=\"4. 数组初始化\"></a>4. 数组初始化</h3><p>初始化数组时需要加上<code>static</code>关键字，此时HLS会直接进行数组初始化，否则会因为初始化引入大量延时  </p>\n<h2 id=\"函数层面优化\"><a href=\"#函数层面优化\" class=\"headerlink\" title=\"函数层面优化\"></a>函数层面优化</h2><p><code>INLINE</code>：通过<code>INLINE</code>处理可以减少综合输出的模块化，使设计更为简洁<br><code>ALLOCATION</code>：可以使用<code>ALLOCATION</code>设置函数实例个数，可以实现函数的并行执行，相当于在空间和时间之间做平衡<br><code>DATAFLOW</code>：类比for循环的<code>dataflow</code>，在函数之间加设通道(<code>FIFO</code>、<code>Ping-Pong RAM</code>)来实现数据流处理  </p>\n<h2 id=\"约束汇总\"><a href=\"#约束汇总\" class=\"headerlink\" title=\"约束汇总\"></a>约束汇总</h2><h4 id=\"吞吐量优化约束\"><a href=\"#吞吐量优化约束\" class=\"headerlink\" title=\"吞吐量优化约束\"></a>吞吐量优化约束</h4><img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%8C%96.png\" class=\"\" title=\"吞吐量优化\"> \n\n<h4 id=\"延时优化约束\"><a href=\"#延时优化约束\" class=\"headerlink\" title=\"延时优化约束\"></a>延时优化约束</h4><img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/%E5%BB%B6%E6%97%B6%E4%BC%98%E5%8C%96.png\" class=\"\" title=\"延时优化\"> \n\n<h4 id=\"空间约束\"><a href=\"#空间约束\" class=\"headerlink\" title=\"空间约束\"></a>空间约束</h4><img src=\"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/%E5%8C%BA%E5%9F%9F%E7%BA%A6%E6%9D%9F.png\" class=\"\" title=\"空间优化\"> ","categories":["HLS"],"tags":["Vitis HLS","FPGA"]},{"title":"博客搭建（hexo+github）","url":"/2024/05/09/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88hexo-github%EF%BC%89/","content":"<h2 id=\"博客搭建基本流程（hexo-github）\"><a href=\"#博客搭建基本流程（hexo-github）\" class=\"headerlink\" title=\"博客搭建基本流程（hexo + github）\"></a>博客搭建基本流程（hexo + github）</h2><h3 id=\"hexo环境搭建\"><a href=\"#hexo环境搭建\" class=\"headerlink\" title=\"hexo环境搭建\"></a>hexo环境搭建</h3><p>hexo环境搭建需要下载node.js、git，下载之后在cmd中输入下面命令检查node、npm、git是否安装成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; node -v</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; npm -v</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; git -v</span><br></pre></td></tr></table></figure>\n\n<p>确认node.js、git安装无误后，使用git bash进行hexo的安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>安装完成之后，创建一个博客文件夹，在git bash中输入如下命令进行初始化和本地预览</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo init                           <span class=\"comment\"># 初始化</span></span><br><span class=\"line\">$ hexo install                        <span class=\"comment\"># 安装组件</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ hexo generate                       <span class=\"comment\"># 生成页面 （可以简写为 hexo g ）</span></span><br><span class=\"line\">$ hexo server                         <span class=\"comment\"># 预览 （默认端口为4000，若被占用可以通过 -p 更换端口）</span></span><br></pre></td></tr></table></figure>\n\n<p>此时访问”localhost:4000”即可预览博客</p>\n<p>博客文件夹目录结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">- _config.yml                          # 站点配置信息  </span><br><span class=\"line\">- package.json                         # 应用程序信息  </span><br><span class=\"line\">- scaffolds                            # 模板文件  </span><br><span class=\"line\">- source                               # 存放用户源文件  </span><br><span class=\"line\">- themes                               # 存放主题文件  </span><br><span class=\"line\">- public                               # 静态网站文件</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"部署到github\"><a href=\"#部署到github\" class=\"headerlink\" title=\"部署到github\"></a>部署到github</h3><p>在部署之前要确保主机通过ssh密钥域github连接，可通过如下命令进行检查</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n\n<p>连接成功后在github中新建博客仓库，仓库名称为”username.github.io”，username为github用户名<br>创建完成之后对<code>_config.yml</code>文件中的deploy部分进行如下修改，将博客部署在main分支</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: git@github.com:Allure-Luv/Allure-Luv.github.io.git</span><br><span class=\"line\">  branch: main</span><br></pre></td></tr></table></figure>\n\n<p>修改完成后，运行如下命令进行部署</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo cl</span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n\n<p>部署之后可以访问<code>username.github.io</code>来查看部署情况</p>\n<h2 id=\"跨设备移植博客\"><a href=\"#跨设备移植博客\" class=\"headerlink\" title=\"跨设备移植博客\"></a>跨设备移植博客</h2><p>根据上述步骤，博客部署在main分支，利用git分支机制，将源码推送至另一分支，即可实现源码的保存<br>在更换设备后，仅需要搭建hexo环境，从github中拉取源码即可，具体步骤如下：<br>a. 在github中创建新的分支，这里为<code>gh-pages</code>，并将其设置为默认分支，为了每次方便上传源码<br>b. 在本地拉取新创建的新分支<br>c. 将文件夹中除<code>.git</code>文件之外所有文件均删除<br>d. 将博客源码除<code>.deploy_git</code>文件复制到拉取的文件夹中（注意要有.gitignore文件）<br>e. 将本地仓库推送至远端仓库<br>注：因为git不支持嵌套，因此在github中拉取的主题中的.git文件需要删除  </p>\n<h2 id=\"博客资源管理\"><a href=\"#博客资源管理\" class=\"headerlink\" title=\"博客资源管理\"></a>博客资源管理</h2><p>通常在 <code>source/images</code> 文件夹下可以存放文章所引用的图片，但当资源较多时，可以启用资源管理文件夹实现分组管理<br>在 <code>_config.yml</code> 文件中置 <code>post_asset_folder</code> 选项为true，这样在进行博客创建的时候，会自动创建一个与文章同名的文件夹用于放置文章引用的资源<br>在这种方式下，图片、链接等无法使用<code>markdown</code>语法链接，具体链接方式为：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% asset_path slug %&#125;</span><br><span class=\"line\">&#123;% asset_img slug [title] %&#125;</span><br><span class=\"line\">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure>","categories":["博客搭建"],"tags":["hexo","github"]}]