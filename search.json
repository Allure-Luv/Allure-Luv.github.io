[{"title":"An Intro to DL for the Physical Layer","url":"/2024/05/30/An%20Intro%20to%20DL%20for%20Physical%20Layer/","content":"<h2 id=\"文章出处\"><a href=\"#文章出处\" class=\"headerlink\" title=\"文章出处\"></a>文章出处</h2><p>O’shea T, Hoydis J. An introduction to deep learning for the physical layer[J]. IEEE Transactions on Cognitive Communications and Networking, 2017, 3(4): 563-575.(Citations 2607)  </p>\n<h2 id=\"论文总览\"><a href=\"#论文总览\" class=\"headerlink\" title=\"论文总览\"></a>论文总览</h2><ul>\n<li><p>主要内容：文章是一篇综述类文章，总结了ML在通信系统物理层上的应用，提出相关观点，并在该领域进行展望</p>\n</li>\n<li><p>主要贡献：</p>\n</li>\n</ul>\n<ol>\n<li>证明使用DNN网络代替发射机、接收机以及信道等通信系统部分是可行的，并可适用于最优解未知的通道模型和损失函数  </li>\n<li>证明上述概念可以扩展至多发多收场景下，利用神经网络有助于解决干扰信道问题。同时，收发机的实现可以根据公共或单独的性能指标进行联合优化  </li>\n<li>介绍了 <code>radio transformer networks</code> ，该网络可以在接收机融入预定义校正算法。该网络可以集成对变换信号执行的任务到端到端训练过程中</li>\n<li>研究了NN在复值样本上解决调制分类问题的可行性，证明其学习到的特征优于并可以取代传统方式</li>\n</ol>\n<h2 id=\"DL在物理层上的潜力\"><a href=\"#DL在物理层上的潜力\" class=\"headerlink\" title=\"DL在物理层上的潜力\"></a>DL在物理层上的潜力</h2><ol>\n<li>传统方式对通信系统的建模很难完美描述其实际特性，使用DL可以降低模型对数学可处理性的要求，同时可以针对特定硬件和无法完美描述的信道进行优化</li>\n<li>传统通信系统设计要求信号处理过程模块化、流程化，但模块化的通信系统已被证明为是次优的，而模块之间的联合优化会使得各个模块的实现十分繁琐，使用DL取代传统物理层不会被严格区分为各个模块，它是针对端到端性能进行优化  </li>\n<li>神经网络的运行能够有很高的并行度和更低的数据精度，因此可以执行速度更快、功耗更低</li>\n<li>结合第3点，目前有足以支撑神经网络计算的硬件平台，例如：GPU、Eyeriss架构等。在这些架构上可以轻松实现高资源利用率、高吞吐量，并只需要最少的特定于应用程序的调整或优化</li>\n</ol>\n<h2 id=\"相关工作\"><a href=\"#相关工作\" class=\"headerlink\" title=\"相关工作\"></a>相关工作</h2>","categories":["论文阅读-通信系统"],"tags":["Physical Layer","Deep Learning","Literature Review"]},{"title":"Vitis HLS 基础","url":"/2024/05/31/Vitis-HLS-%E5%9F%BA%E7%A1%80/","content":"<p>Vitis HLS 基础学习笔记</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"1-任意精度数据类型\"><a href=\"#1-任意精度数据类型\" class=\"headerlink\" title=\"1. 任意精度数据类型\"></a>1. 任意精度数据类型</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;ap_int.h&gt;</span><br><span class=\"line\">ap_[u]int&lt;W&gt;  // 最大可扩展至32k位</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;ap_fixed.h&gt;</span><br><span class=\"line\">ap_[u]fixed&lt;W, I, Q, O&gt;    // W总位宽、I整数位宽、Q量化模式、O溢出模式</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-变量初始化\"><a href=\"#2-变量初始化\" class=\"headerlink\" title=\"2. 变量初始化\"></a>2. 变量初始化</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ap_int&lt;6&gt; a_6bit_var_c = -22;</span><br><span class=\"line\">ap_int&lt;6&gt; a_6bit_var_d(22);</span><br><span class=\"line\">ap_int&lt;6&gt; a_6bit_var_r2(&quot;0b101010&quot;, 2);   // 指定进制数</span><br><span class=\"line\">ap_int&lt;6&gt; a_6bit_var_r2(&quot;101010&quot;, 2);</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-数据类型转换\"><a href=\"#3-数据类型转换\" class=\"headerlink\" title=\"3. 数据类型转换\"></a>3. 数据类型转换</h3><p>显示转换</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(Expected type) Variable</span><br><span class=\"line\">Expected type (Variable)</span><br><span class=\"line\">```  </span><br><span class=\"line\">常用运算的数据类型转换</span><br><span class=\"line\">&#123;% asset_img 1.jpg 数据类型转换 %&#125;  </span><br><span class=\"line\">可以使用`&lt;typeinfo&gt;`库文件中的`typeid`来查看数据类型</span><br><span class=\"line\"></span><br><span class=\"line\">## for循环优化</span><br><span class=\"line\"></span><br><span class=\"line\">### 1. 衡量指标</span><br><span class=\"line\"></span><br><span class=\"line\">`Loop Trip Count`：循环触发次数  </span><br><span class=\"line\">`Loop Iteration Latency`：迭代延时（单次迭代时延）  </span><br><span class=\"line\">`Loop Iteration Interval`：迭代间隔（两次迭代间隔）  </span><br><span class=\"line\">`Loop Latency`：循环时延（迭代时延 * 迭代次数）  </span><br><span class=\"line\">`Function Latency`：函数时延（完整for循环执行时延）  </span><br><span class=\"line\">`Function Iteration Interval`：函数间隔（两次循环的间隔，考虑到循环条件的判断，可能会多一个周期）</span><br><span class=\"line\"></span><br><span class=\"line\">### 2. 流水线处理</span><br><span class=\"line\"></span><br><span class=\"line\">使用`#pragma HLS PIPLINE`添加约束  </span><br><span class=\"line\">&#123;% asset_img for_pipline.png 流水线处理 %&#125;  </span><br><span class=\"line\">流水线处理使得数据读取、计算、存储三个过程在一定程度上并行处理，即上一个数据在计算过程中就开始读取下一个数据  </span><br><span class=\"line\"></span><br><span class=\"line\">### 3. 循环展开</span><br><span class=\"line\"></span><br><span class=\"line\">使用`#pragma HLS UNROLL`添加约束  </span><br><span class=\"line\">&#123;% asset_img for_unroll.png 循环展开 %&#125;    </span><br><span class=\"line\">可以根据循环迭代参数`i`对循环计算并行处理，同时可以约束展开的子循环个数  </span><br><span class=\"line\"></span><br><span class=\"line\">### 4. 循环融合</span><br><span class=\"line\"></span><br><span class=\"line\">使用`#pragma HLS merge`添加约束  </span><br><span class=\"line\">&#123;% asset_img merge.png 循环融合 %&#125;   </span><br><span class=\"line\">循环融合可以将两个不具有顺序逻辑的循环同时执行  </span><br><span class=\"line\">循环边界的界定如下：</span><br><span class=\"line\">- `Loop_A`的循环次数为`M`，`Loop_B`的循环次数为`N`，合并后循环次数为`MAX(M, N)`  </span><br><span class=\"line\">- 若一个循环边界为变量，另一个为常量时，无法合并  </span><br><span class=\"line\">- 两个循环边界均为变量时，可以约束为共同循环部分和额外循环部分  </span><br><span class=\"line\"></span><br><span class=\"line\">### 5. 数据流处理</span><br><span class=\"line\">使用`#pragma HLS dataflow`添加约束  </span><br><span class=\"line\">&#123;% asset_img dataflow.png 数据流处理 %&#125;  </span><br><span class=\"line\">数据流处理用于处理多循环连接问题，循环之间的通道使用`RAM`、`FIFO`或`Reg`实现，加速方式为在`Loop_B`处理的同时`Loop_A`进行下一组数据的处理</span><br><span class=\"line\"></span><br><span class=\"line\">#### `dataflow`的局限性与解决方式  </span><br><span class=\"line\"></span><br><span class=\"line\">当出现一个循环的结果要送入两个不同循环进行后续处理的情况时，无法直接使用dataflow  </span><br><span class=\"line\">&#123;% asset_img dataflow局限性1.png dataflow局限性1 %&#125;   </span><br><span class=\"line\">此时需要将第一个循环结果复制之后，分别送入两个循环  </span><br><span class=\"line\">&#123;% asset_img dataflow1.png dataflow局限性1处理 %&#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">当出现一个循环结果经过不同处理过程最终又送入一个循环的情况时，无法直接使用dataflow  </span><br><span class=\"line\">&#123;% asset_img dataflow局限性2.png dataflow局限性2 %&#125;   </span><br><span class=\"line\">此时需要保证两个分支经过相同的处理模块，不需要处理时在模块内为简单的复制  </span><br><span class=\"line\">&#123;% asset_img dataflow2.png dataflow局限性2处理 %&#125;     </span><br><span class=\"line\"></span><br><span class=\"line\">#### `dataflow`的存储管理  </span><br><span class=\"line\"></span><br><span class=\"line\">标量、指针、引用变量以及函数返回值，HLS使用FIFO实现通道  </span><br><span class=\"line\">数组，`HLS`使用`FIFO`或`ping-pong ram`实现：  </span><br><span class=\"line\">- 若HLS确定数据流为顺序的，则默认使用深度为1的FIFO  </span><br><span class=\"line\">- 若不能确定则使用`ping-pong ram`    </span><br><span class=\"line\"></span><br><span class=\"line\">上述配置可以在`congfig_dataflow`中配置，明确设定FIFO深度，存储器尺寸等  </span><br><span class=\"line\"></span><br><span class=\"line\">### 6. 嵌套循环优化   </span><br><span class=\"line\"></span><br><span class=\"line\">嵌套循环主要通过`pipline`进行优化，`pipline`会合并上层循环、展开下层循环</span><br><span class=\"line\"></span><br><span class=\"line\">#### a. 循环边界为常数，循环体仅在最内层循环  </span><br><span class=\"line\"></span><br><span class=\"line\">对外层循环做pipline处理，会使内部循环全部展开，可以达到最低延时但是会消耗更多资源  </span><br><span class=\"line\">对内层循环做pipline处理，会使外部循环展开，即若外部循环边界为`M`，内部循环边界为`N`，相当于执行`M*N`次内部循环，效果介于不处理和对外层循环处理之间  </span><br><span class=\"line\">注：`Loop_flatten`展开最外层循环要求必须为`a`、`b`两种情况</span><br><span class=\"line\"></span><br><span class=\"line\">#### b. 循环边界为常数，循环体存在多层循环  </span><br><span class=\"line\"></span><br><span class=\"line\">以如下代码为例：  </span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% asset_img imperfect_loop1.png 非完美循环示例 %&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">若对最内层做`pipline`处理，由于在`Col`循环内存在初始化，无法展开，仅能对`Row`和`Col`进行展开，最终结果为两层嵌套循环   </span><br><span class=\"line\">若对中间层循环做`pipline`处理，仍为展开`Row`和`Col`，同时展平最内层循环，最终仅有一层循环  </span><br><span class=\"line\">若对最外层循环做`pipline`处理，会展开所有子循环，即最终仅有一层循环且循环边界为`Col`的循环边界</span><br><span class=\"line\"></span><br><span class=\"line\">#### unroll vs flatten  </span><br><span class=\"line\"></span><br><span class=\"line\">对于for循环嵌套来说，`flatten`为合并两次循环，`unroll`为单个循环  </span><br><span class=\"line\"></span><br><span class=\"line\">``` Cpp</span><br><span class=\"line\">    Loop_A:</span><br><span class=\"line\">    for (i = 0; i &lt; 3; i++) &#123;</span><br><span class=\"line\">        Loop_B:</span><br><span class=\"line\">        for (j = 0; j &lt; 3; j++) &#123;</span><br><span class=\"line\">            Loop_C:</span><br><span class=\"line\">            for (k = 0; k &lt; 3; k++) &#123;</span><br><span class=\"line\">                Loop_Entiy;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">若对`Loop_B`使用`pipline`进行优化，HLS会合并（flatten）上层循环，展开（unroll）下层循环  </span><br><span class=\"line\">合并`Loop_A`与`Loop_B`，即外部循环变为一个同时循环边界为两个循环的和  </span><br><span class=\"line\">展开`Loop_C`，即同时计算`Loop_C`下每个循环变量对应的循环体   </span><br><span class=\"line\">故最终约束结果为对3个`Loop_Entity`循环6次</span><br><span class=\"line\"></span><br><span class=\"line\">### 7. for循环其他优化  </span><br><span class=\"line\"></span><br><span class=\"line\">#### 函数实例的并行计算 </span><br><span class=\"line\"></span><br><span class=\"line\">使用`#pragma HLS ALLOCATIN instances=  limit=`实现函数并行约束  </span><br><span class=\"line\">上述约束可以实现函数的示例，并进行并行计算  </span><br><span class=\"line\"></span><br><span class=\"line\">#### pipline rewind</span><br><span class=\"line\"></span><br><span class=\"line\">在`pipline`的约束下，选用`rewind`选项，可以实现不同循环之间的流水线处理  </span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% asset_img rewind.png pipline rewind %&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">#### 循环边界为变量  </span><br><span class=\"line\"></span><br><span class=\"line\">循环边界为变量时，无法确定延时，解决方案如下：  </span><br><span class=\"line\">- 设定`tripcount`参数  </span><br><span class=\"line\">- 指定循环边界的数据类型为`ap_(u)int`</span><br><span class=\"line\">- 使用`assert` </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>#include &lt;assert.h&gt; </p>\n<p>void test() {<br>    int i;<br>    assert (width &lt; 5);<br>    for (i &#x3D; 0; i &lt; width; i++) {<br>        Loop_Entity;<br>    }<br>}</p>\n<pre><code>\n三种方式相比之下采用assert延时最短使用资源最少\n</code></pre>\n","categories":["HLS"],"tags":["Vitis HLS","FPGA"]},{"title":"博客搭建（hexo+github）","url":"/2024/05/09/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88hexo-github%EF%BC%89/","content":"<h2 id=\"博客搭建基本流程（hexo-github）\"><a href=\"#博客搭建基本流程（hexo-github）\" class=\"headerlink\" title=\"博客搭建基本流程（hexo + github）\"></a>博客搭建基本流程（hexo + github）</h2><h3 id=\"hexo环境搭建\"><a href=\"#hexo环境搭建\" class=\"headerlink\" title=\"hexo环境搭建\"></a>hexo环境搭建</h3><p>hexo环境搭建需要下载node.js、git，下载之后在cmd中输入下面命令检查node、npm、git是否安装成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; node -v</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; npm -v</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; git -v</span><br></pre></td></tr></table></figure>\n\n<p>确认node.js、git安装无误后，使用git bash进行hexo的安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>安装完成之后，创建一个博客文件夹，在git bash中输入如下命令进行初始化和本地预览</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo init                           <span class=\"comment\"># 初始化</span></span><br><span class=\"line\">$ hexo install                        <span class=\"comment\"># 安装组件</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ hexo generate                       <span class=\"comment\"># 生成页面 （可以简写为 hexo g ）</span></span><br><span class=\"line\">$ hexo server                         <span class=\"comment\"># 预览 （默认端口为4000，若被占用可以通过 -p 更换端口）</span></span><br></pre></td></tr></table></figure>\n\n<p>此时访问”localhost:4000”即可预览博客</p>\n<p>博客文件夹目录结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">- _config.yml                          # 站点配置信息  </span><br><span class=\"line\">- package.json                         # 应用程序信息  </span><br><span class=\"line\">- scaffolds                            # 模板文件  </span><br><span class=\"line\">- source                               # 存放用户源文件  </span><br><span class=\"line\">- themes                               # 存放主题文件  </span><br><span class=\"line\">- public                               # 静态网站文件</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"部署到github\"><a href=\"#部署到github\" class=\"headerlink\" title=\"部署到github\"></a>部署到github</h3><p>在部署之前要确保主机通过ssh密钥域github连接，可通过如下命令进行检查</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n\n<p>连接成功后在github中新建博客仓库，仓库名称为”username.github.io”，username为github用户名<br>创建完成之后对<code>_config.yml</code>文件中的deploy部分进行如下修改，将博客部署在main分支</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: git@github.com:Allure-Luv/Allure-Luv.github.io.git</span><br><span class=\"line\">  branch: main</span><br></pre></td></tr></table></figure>\n\n<p>修改完成后，运行如下命令进行部署</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo cl</span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n\n<p>部署之后可以访问<code>username.github.io</code>来查看部署情况</p>\n<h2 id=\"跨设备移植博客\"><a href=\"#跨设备移植博客\" class=\"headerlink\" title=\"跨设备移植博客\"></a>跨设备移植博客</h2><p>根据上述步骤，博客部署在main分支，利用git分支机制，将源码推送至另一分支，即可实现源码的保存<br>在更换设备后，仅需要搭建hexo环境，从github中拉取源码即可，具体步骤如下：<br>a. 在github中创建新的分支，这里为<code>gh-pages</code>，并将其设置为默认分支，为了每次方便上传源码<br>b. 在本地拉取新创建的新分支<br>c. 将文件夹中除<code>.git</code>文件之外所有文件均删除<br>d. 将博客源码除<code>.deploy_git</code>文件复制到拉取的文件夹中（注意要有.gitignore文件）<br>e. 将本地仓库推送至远端仓库<br>注：因为git不支持嵌套，因此在github中拉取的主题中的.git文件需要删除  </p>\n<h2 id=\"博客资源管理\"><a href=\"#博客资源管理\" class=\"headerlink\" title=\"博客资源管理\"></a>博客资源管理</h2><p>通常在 <code>source/images</code> 文件夹下可以存放文章所引用的图片，但当资源较多时，可以启用资源管理文件夹实现分组管理<br>在 <code>_config.yml</code> 文件中置 <code>post_asset_folder</code> 选项为true，这样在进行博客创建的时候，会自动创建一个与文章同名的文件夹用于放置文章引用的资源<br>在这种方式下，图片、链接等无法使用<code>markdown</code>语法链接，具体链接方式为：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% asset_path slug %&#125;</span><br><span class=\"line\">&#123;% asset_img slug [title] %&#125;</span><br><span class=\"line\">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure>","categories":["博客搭建"],"tags":["hexo","github"]}]